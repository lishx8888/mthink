# 思维导图手动布局逻辑分析

## 核心布局流程

手动布局（通过"自动布局"按钮触发）的核心流程由 `autoLayout()` 方法实现，包含以下步骤：

### 1. 初始化准备
- **保存状态**：`this.saveState()` 保存当前布局状态，支持撤销操作
- **计算节点尺寸**：`this.calculateNodeSizes()` 计算所有节点的宽度和高度
- **生成节点编号**：`this.generateNodeNumbersForAutoLayout()` 为所有没有编号的节点生成编号

### 2. 节点分离
- **正向节点**：右侧布局，编号非负的节点
- **反向节点**：左侧布局，编号为负的节点

### 3. 右侧正向布局计算
- **计算节点位置**：`this.calculateRightNodePositions(rightNodes)` 计算正向布局节点位置
- **优化节点间距**：`this.optimizeNodeSpacing()` 确保相邻节点（包括整个分支）之间保持至少20px的垂直间距

### 4. 左侧反向布局计算
- **计算节点位置**：`this.calculateLeftNodePositions(leftNodes)` 计算反向布局节点位置
- **优化节点间距**：`this.optimizeReverseNodeSpacing()` 确保反向布局节点之间的适当间距
- **优化一级节点间距**：`this.optimizeReverseLevel1Spacing()` 对直接连接到0号节点的父节点进行特殊处理

### 5. 节点0对齐
- **保存右侧计算的Y坐标**：`node0YFromRight` 保存由右侧子节点决定的0号节点Y坐标
- **调整左侧节点**：根据右侧计算的Y坐标调整所有左侧节点的位置，确保左右两侧布局对齐

### 6. 整体居中
- **计算偏移量**：计算将0号节点移动到原点(0,0)所需的偏移量
- **整体移动**：将所有节点按照计算的偏移量整体移动，使0号节点位于中心位置

### 7. 渲染更新
- **渲染布局**：`this.render()` 渲染更新后的布局

## 关键布局算法

### 1. 节点间距优化（正向布局）

#### 核心逻辑：自底而上计算，确保相邻节点（包括整个分支）之间保持至少20px的垂直间距

**步骤**：
1. **深度计算**：计算所有正向节点的深度
2. **按深度分组**：从最深的节点开始处理（自底而上）
3. **父节点处理**：为每个父节点处理其子节点
4. **边界计算**：计算每个子节点（包括其整个子树）的边界
5. **间距调整**：从顶部开始，确保每个子节点与其上方的子节点保持至少20px的间距
6. **父节点对齐**：调整所有正向父节点的Y坐标，使其与子节点对齐

**关键函数**：
- `calculateSubtreeBounds(node)`：计算节点及其所有后代的边界
- `adjustNodeAndDescendantsY(node, yOffset)`：调整节点及其所有后代的Y坐标

### 2. 反向节点间距优化

#### 核心逻辑：自底而上计算，确保相邻分根节点（包括整个分支）之间保持至少20px的垂直间距

**步骤**：
1. **深度计算**：计算所有反向节点的深度（深度越大，离0节点越远）
2. **按深度分组**：从最深的节点开始处理（从外到内）
3. **子节点处理**：为每个子节点处理其父节点（分根）
4. **边界计算**：计算每个分根的边界（包括其所有父节点）
5. **间距调整**：从顶部开始，确保每个分根与其上方的分根保持至少20px的间距

**关键函数**：
- `calculateRootBounds(root)`：计算分根及其所有祖先的边界
- `adjustRootAndAncestorsY(root, yOffset)`：调整分根及其所有祖先的Y坐标

### 3. 一级分根节点间距优化

#### 核心逻辑：专门处理直接连接到0号节点的父节点（一级分根）

**步骤**：
1. **获取一级分根**：获取直接连接到0号节点的父节点
2. **排序分根**：按节点编号自然排序一级分根
3. **边界计算**：计算每个一级分根的边界（包括其所有子节点）
4. **间距调整**：从顶部开始，确保每个一级分根与其上方的分根保持至少20px的间距

## 边界计算方法

### 1. 子树边界计算（正向布局）

**函数**：`calculateSubtreeBounds(node)`

**逻辑**：
- 初始化边界为当前节点的边界
- 递归计算所有子节点的边界
- 更新边界为包含所有子节点的最小矩形

### 2. 分根边界计算（反向布局）

**函数**：`calculateRootBounds(root)`

**逻辑**：
- 初始化边界为当前分根的边界
- 递归计算所有父节点的边界
- 更新边界为包含所有父节点的最小矩形

## 布局调整方法

### 1. 调整节点及其后代（正向布局）

**函数**：`adjustNodeAndDescendantsY(node, yOffset)`

**逻辑**：
- 调整当前节点的Y坐标
- 递归调整所有子节点的Y坐标

### 2. 调整分根及其祖先（反向布局）

**函数**：`adjustRootAndAncestorsY(root, yOffset)`

**逻辑**：
- 调整当前分根的Y坐标
- 递归调整所有父节点的Y坐标

## 节点对齐策略

### 1. 父节点对齐（正向布局）

**逻辑**：
- 奇数个子节点：使用中间子节点的Y坐标
- 偶数个子节点：使用中间两个子节点Y坐标的均值

### 2. 子节点对齐（反向布局）

**逻辑**：
- 奇数个父节点：使用中间父节点的Y坐标
- 偶数个父节点：使用中间两个父节点Y坐标的均值

### 3. 左右布局对齐

**逻辑**：
- 0号节点的Y坐标由右侧子节点决定
- 调整左侧所有节点的Y坐标，使左侧父节点的中央节点Y坐标与0号节点的Y坐标保持一致

## 布局特点与优势

1. **分层布局**：根据节点编号的层级结构进行分层布局
2. **间距优化**：确保节点之间有足够的间距，避免重叠
3. **左右对齐**：左右两侧布局通过节点0保持对齐
4. **整体居中**：最终布局以节点0为中心，视觉效果平衡
5. **自底而上计算**：从最深层节点开始计算，确保布局稳定性
6. **边界感知**：考虑整个分支的边界，而不仅仅是单个节点

## 适用场景

- **任意规模思维导图**：手动布局适用于所有规模的思维导图
- **复杂结构**：能够处理复杂的分支结构和多层次节点
- **视觉平衡**：确保最终布局视觉平衡，节点分布合理

## 性能考虑

- **时间复杂度**：O(n²)，其中n是节点数量，主要受边界计算和间距调整影响
- **空间复杂度**：O(n)，需要存储节点深度、边界等中间数据
- **优化建议**：对于大型思维导图（>200节点），建议使用手动触发的布局方式，避免实时布局影响性能