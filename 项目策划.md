# 思维导图画布节点编号与自动布局优化项目策划

## 1. 项目背景

思维导图画布的自动布局功能已完成优化，实现了基于节点编号的特定对齐规则，确保一次点击即可达到稳定状态。系统已解决以下问题：
- ✅ 节点编号逻辑不清晰问题，正向和反向思维节点编号已明确分离
- ✅ 布局稳定性不足问题，一次点击即可达到预期效果
- ✅ 对齐规则未完全按用户要求实现问题，已实现所有要求的对齐规则

## 1.1 新增功能

- **节点编号与文字内容分离**：节点编号和文字内容使用独立字段，避免相互干扰
- **自动布局节点编号生成**：为无编号节点自动生成合理的编号
- **坐标系统优化**：将(0,0)点从页面左上角移到页面中央
- **保存与导入优化**：确保节点编号和文字内容在保存和导入过程中不丢失
- **水平节点间距优化**：确保正向布局中节点不重叠，保持相邻节点边的108px间距
- **文本溢出处理**：实现文本自动换行逻辑和CSS clip-path，确保文本不会超出节点框
- **端点位置固定**：编辑节点文本后，节点的端点位置保持固定
- **节点对齐优化**：使用第一个节点的端点位置作为基准，确保所有子节点左端点对齐，所有父节点右端点对齐
- **根节点位置固定**：确保根节点固定在中心(0,0)，包括编辑文本时
- **默认节点宽度**：所有节点默认宽度为400px，保持一致性
- **编辑模式优化**：编辑节点文本时，节点高度根据内容自动调整
- **多选节点样式设置**：选择多个节点时，只修改用户实际调整的样式属性，保持其他属性不变
- **连接线颜色保存**：确保连接线颜色在保存和加载过程中不丢失，保持视觉一致性
- **SVG/PNG导出优化**：确保导出的文件中文本与编辑界面保持一致的左对齐样式，避免文本变成单行显示

## 2. 需求分析

### 2.1 核心功能需求

#### 2.1.1 节点编号规则

**以初始节点为中心节点（编号0），实现以下编号逻辑：**

1. **逆向思维节点（左侧父节点）**：
   - 一级节点：根据节点从上到下的顺序依次为-1、-2、-3...
   - 二级节点：在一级节点编号基础上扩展，如-2号节点的子节点依次为-21、-22、-23...
   - 三级节点：在二级节点编号基础上扩展，如-22号节点的子节点依次为-221、-222、-223...
   - 以此类推，层级越深，编号越长

2. **正向思维节点（右侧子节点）**：
   - 一级节点：根据节点从上到下的顺序依次为1、2、3...
   - 二级节点：在一级节点编号基础上扩展，如2号节点的子节点依次为21、22、23...
   - 三级节点：在二级节点编号基础上扩展，如22号节点的子节点依次为221、222、223...
   - 以此类推，层级越深，编号越长

#### 2.1.2 自动布局规则

**逆向思维布局规则**：
- 所有没有上级节点的节点（根节点）Y坐标从上往下按编号排序，保持一个单位的竖向间隔
- 上级节点有奇数个时，存在中央节点，其Y坐标等于子节点的Y坐标
- 上级节点有偶数个时，中间节点是两个，这两个节点Y坐标的均值等于子节点的Y坐标
- X坐标为负，与正向思维节点互不干扰

**正向思维布局规则**：
- 所有没有下级节点的节点（叶子节点）Y坐标从上往下按编号排序，保持一个单位的竖向间隔
- 下级节点有奇数个时，存在中央节点，其Y坐标等于父节点的Y坐标
- 下级节点有偶数个时，中间节点是两个，这两个节点Y坐标的均值等于父节点的Y坐标
- X坐标为正，与逆向思维节点互不干扰

### 2.2 非功能需求

- **稳定性**：一次点击自动布局即可达到稳定状态
- **美观性**：布局从中间往两侧排列，节点分布均匀
- **性能**：布局计算时间不超过1秒
- **兼容性**：支持主流浏览器（Chrome、Firefox、Safari、Edge）

## 3. 技术方案

### 3.1 系统架构

保持现有系统架构不变，主要优化以下模块：

1. **节点编号模块**：负责生成和管理节点编号
2. **自动布局模块**：实现基于新规则的布局算法
3. **渲染模块**：确保布局后的节点正确渲染

### 3.2 核心算法设计

#### 3.2.1 节点编号算法

```javascript
// 生成节点编号
function generateNodeNumber(parentNode, direction) {
    // direction: 'forward' 或 'reverse'
    const parentNumber = parentNode.text;
    const siblings = direction === 'forward' ? parentNode.children : parentNode.parents;
    const siblingNumbers = siblings.map(sibling => parseInt(sibling.text) || 0);
    const maxNumber = Math.max(...siblingNumbers);
    const newNumber = maxNumber + 1;
    
    return direction === 'forward' ? `${parentNumber}${newNumber}` : `${parentNumber}${newNumber}`;
}
```

#### 3.2.2 自动布局算法

```javascript
// 自动布局主函数
function autoLayout() {
    // 计算节点深度
    const nodeDepths = calculateNodeDepths();
    
    // 按层级分组节点
    const levelNodes = getNodesByLevel(nodeDepths);
    
    // 计算X坐标
    const levelXCoords = calculateLevelXCoords(levelNodes);
    
    // 计算Y坐标
    const leafYCoords = calculateLeafYCoords(levelNodes);
    
    // 应用坐标
    applyNodePositions(levelXCoords, leafYCoords);
    
    // 确保布局稳定
    ensureLayoutStability();
}
```

#### 3.2.3 节点布局逻辑（树叶与树枝协同）

##### 3.2.3.1 节点类型明确定义

**树叶节点**（Leaf Nodes）：
- 所有没有子节点的外沿节点
- 思维导图的终端节点
- 负责展示思维导图的具体内容细节

**树枝节点**（Branch Nodes）：
- 所有有子节点的内部节点
- 包括树干节点和分叉节点
- 负责连接和组织树叶节点，形成树状结构

##### 3.2.3.2 树叶节点布局逻辑（竖向分布）

树叶节点主要处理竖向的终端节点分布，确保：

1. **编号排序**：
   - 叶子节点定义：没有子节点的节点
   - 排序规则：按叶子节点的编号逐级扫描排序
     - 首先比较首个编号的大小，小的排前面
     - 如果首个编号相同，再比较下一位的编号（如21与22，首个编号都是2，下一位编号分别是1和2，那么21排前面）
     - 依次比较后续位的编号，直到确定大小顺序

2. **Y坐标分配（间距）**：
   - 按排序顺序从顶部到底部分配Y坐标
   - 每个叶子节点之间保持一个固定的单位间距（单位间距 = 节点高度 + 垂直边缘间距）
   - 整体分布围绕初始节点（0号）的Y坐标对称

##### 3.2.3.3 树枝节点布局逻辑（横向与竖向协同）

树枝节点处理横向分布和竖向对齐，确保：

1. **横向分布**：
   - 按节点深度从中心向外分布（深度1、2、3...）
   - 节点之间保持固定的水平间距
   - 正向思维节点向右分布，反向思维节点向左分布

2. **竖向对齐（树干逻辑）**：
   - 树干逻辑适用于所有树枝节点（非叶子节点）
   - **奇数个子节点场景**：
     - 父节点的Y坐标等于中间子节点的Y坐标
     - 示例：节点3有5个子节点（31, 32, 33, 34, 35），则节点3的Y坐标与33的Y坐标相同
     - 中间子节点的虚拟子节点（如330）必须与父节点Y坐标对齐
   - **偶数个子节点场景**：
     - 父节点的Y坐标等于中间两个子节点的Y坐标均值
     - 示例：节点4有6个子节点（41, 42, 43, 44, 45, 46），则节点4的Y坐标等于43和44的Y坐标均值
     - 中间两个子节点的虚拟子节点（如430, 440）必须与父节点Y坐标对齐

3. **初始节点（0号节点）特殊处理**：
   - 作为整个思维导图的中心，0号节点的Y坐标固定为画布中心位置
   - 当0号节点有奇数个子节点时，中央树干节点的Y坐标与0号节点相同
   - 当0号节点有偶数个子节点时，中间两个分叉树干节点的Y坐标均值与0号节点相同

##### 3.2.3.4 协同工作原理（叶子节点与树干节点的衔接机制）

树叶节点逻辑和树枝节点逻辑相互补充，形成稳定的确定状态，两者的衔接机制如下：

### 1. 节点类型明确定义

**叶子节点**：
- 定义：没有子节点的节点
- 职责：实现竖向的排序以及间距分配
- 特征：树形结构的终端节点，负责展示具体内容细节

**树干节点**：
- 定义：有子节点的节点（包括所有非叶子节点）
- 职责：保证树枝能找准其中央的干节点
- 特征：树形结构的内部节点，负责连接和组织树叶节点

### 2. 衔接机制

#### 2.1 布局计算顺序（先树叶后树干）

1. **树叶节点布局**：
   - 首先计算所有树叶节点的Y坐标
   - 按编号逐级扫描排序叶子节点
   - 按排序顺序分配Y坐标，保持固定单位间距
   - 整体分布围绕初始节点（0号）的Y坐标对称

2. **树干节点布局**：
   - 基于树叶节点的Y坐标计算所有树干节点的Y坐标
   - 按深度从最深的树干节点开始处理（从叶子节点的直接父节点开始）
   - 奇数个子节点时，树干节点Y坐标等于中间子节点Y坐标
   - 偶数个子节点时，树干节点Y坐标等于中间两个子节点Y坐标平均值

3. **X坐标计算**：
   - 最后计算所有节点的X坐标
   - 按节点深度从中心向外分布
   - 正向思维节点向右分布，反向思维节点向左分布

#### 2.2 坐标传递机制

**从叶子节点到树干节点的Y坐标传递**：
- 叶子节点的Y坐标是所有上层树干节点Y坐标的基础
- 每个树干节点的Y坐标直接由其子节点的Y坐标计算得出
- 树干节点通过中间子节点的Y坐标与下层叶子节点建立连接

**树干节点对叶子节点的约束**：
- 树干节点的结构（子节点数量和分布）决定了叶子节点的分布范围
- 树干节点的对齐规则确保叶子节点的分布保持整体平衡
- 树干节点为中心的结构确保整个树形布局的稳定性

### 3. 稳定性保障

1. **单向依赖**：
   - 树干节点的Y坐标完全依赖于其子节点的Y坐标
   - 叶子节点的Y坐标不依赖于树干节点，只受限于排序和间距规则
   - 这种单向依赖关系确保布局计算的稳定收敛

2. **层级处理**：
   - 按深度从下往上处理树干节点，确保子节点坐标先于父节点计算
   - 这种层级处理方式避免了循环依赖，确保布局的确定性

3. **固定约束**：
   - 0号节点Y坐标固定为画布中心，作为整个布局的基准点
   - 叶子节点间距固定，确保布局的一致性
   - 树干节点对齐规则明确，确保布局的稳定性

4. **稳定收敛**：
   - 一次迭代即可完成所有节点的坐标计算
   - 无需多次点击即可达到稳定状态
   - 任意节点的移动都会触发整个布局的重新计算，保持整体稳定性

**实现代码：**

```javascript
// 计算分支中的叶子节点数量
countLeafNodesInBranch(node) {
    if (node.children.length === 0) {
        return 1;
    }
    return node.children.reduce((sum, child) => {
        return sum + this.countLeafNodesInBranch(child);
    }, 0);
}

// 调整所有后代节点的Y坐标
adjustAllDescendants(node, newY, leafYCoords) {
    const originalY = node.y;
    const deltaY = newY - originalY;
    
    // 调整当前节点的Y坐标
    node.y = newY;
    leafYCoords.set(node.id, newY);
    
    // 递归调整所有子节点的Y坐标
    node.children.forEach(child => {
        child.y += deltaY;
        leafYCoords.set(child.id, child.y);
        this.adjustAllDescendants(child, child.y, leafYCoords);
    });
}

// 为树干节点空出额外空间，避免被其他分支遮挡
makeSpaceForTrunk(children, trunkIndex, trunkY, unitSpacing, leafYCoords) {
    // 确保树干节点的Y坐标正确
    children[trunkIndex].y = trunkY;
    this.adjustAllDescendants(children[trunkIndex], trunkY, leafYCoords);
    
    // 调整树干节点上方的节点（向上移动）
    for (let i = trunkIndex - 1; i >= 0; i--) {
        const child = children[i];
        const nextChild = children[i + 1];
        child.y = nextChild.y - unitSpacing;
        this.adjustAllDescendants(child, child.y, leafYCoords);
    }
    
    // 调整树干节点下方的节点（向下移动）
    let previousY = trunkY;
    for (let i = trunkIndex + 1; i < children.length; i++) {
        const child = children[i];
        child.y = previousY + unitSpacing;
        previousY = child.y;
        this.adjustAllDescendants(child, child.y, leafYCoords);
    }
}

// 计算叶子节点的Y坐标（树叶节点布局）
calculateLeafYCoords(leafNodes) {
    const leafYCoords = new Map();
    const baseY = 200;
    const verticalEdgeSpacing = 20;
    const unitSpacing = 49.599999999999994 + verticalEdgeSpacing;
    
    // 找到初始节点（编号为"0"）
    const initialNode = this.nodes.find(node => node.text === "0") || this.nodes[0];
    
    if (initialNode) {
        // 为初始节点设置Y坐标
        initialNode.y = baseY;
        leafYCoords.set(initialNode.id, baseY);
        
        // 计算树的最大级别数
        const maxLevel = this.calculateMaxTreeLevel();
        
        // 按编号逐级扫描排序叶子节点
        const sortedLeafNodes = leafNodes.sort((a, b) => {
            // 按编号逐级扫描排序
            const numA = a.text;
            const numB = b.text;
            
            // 处理负号
            const isANegative = numA.startsWith('-');
            const isBNegative = numB.startsWith('-');
            
            if (isANegative && !isBNegative) {
                return -1;
            } else if (!isANegative && isBNegative) {
                return 1;
            }
            
            // 提取数字部分（去掉负号）
            const numAPart = isANegative ? numA.slice(1) : numA;
            const numBPart = isBNegative ? numB.slice(1) : numB;
            
            // 按字符逐个比较
            for (let i = 0; i < Math.max(numAPart.length, numBPart.length); i++) {
                const digitA = parseInt(numAPart[i] || 0);
                const digitB = parseInt(numBPart[i] || 0);
                
                if (digitA < digitB) {
                    return isANegative ? 1 : -1;
                } else if (digitA > digitB) {
                    return isANegative ? -1 : 1;
                }
            }
            
            // 如果所有数字都相同，则较短的编号排在前面
            if (numAPart.length < numBPart.length) {
                return isANegative ? 1 : -1;
            } else if (numAPart.length > numBPart.length) {
                return isANegative ? -1 : 1;
            }
            
            return 0;
        });
        
        // 为所有叶子节点分配Y坐标
        if (sortedLeafNodes.length > 0) {
            const totalHeight = (sortedLeafNodes.length - 1) * unitSpacing;
            const startY = baseY - totalHeight / 2;
            
            sortedLeafNodes.forEach((leafNode, index) => {
                // 真实叶子节点按顺序分配Y坐标
                const y = startY + index * unitSpacing;
                leafNode.y = y;
                leafYCoords.set(leafNode.id, y);
            });
        }
        
        // 计算非叶子节点的Y坐标
        this.calculateNonLeafYCoords(leafYCoords, unitSpacing);
    }
    
    return leafYCoords;
}

// 计算非叶子节点的Y坐标（树枝节点布局）
calculateNonLeafYCoords(leafYCoords, unitSpacing) {
    // 找出所有非叶子节点
    const nonLeafNodes = this.nodes.filter(node => node.children.length > 0);
    
    // 按深度排序，从最深的节点开始处理
    nonLeafNodes.sort((a, b) => {
        const depthA = this.calculateNodeDepth(a);
        const depthB = this.calculateNodeDepth(b);
        return depthB - depthA;
    });
    
    // 处理所有非叶子节点
    nonLeafNodes.forEach(node => {
        // 按节点编号自然排序子节点
        const sortedChildren = [...node.children].sort((a, b) => {
            return a.text.localeCompare(b.text, undefined, { numeric: true, sensitivity: 'base' });
        });
        
        // 应用树干对齐逻辑
        if (sortedChildren.length > 0) {
            if (sortedChildren.length % 2 === 1) {
                // 奇数个子节点：父节点Y坐标等于中间子节点Y坐标
                const middleIndex = Math.floor(sortedChildren.length / 2);
                
                // 对于0号节点的中间子节点（树干节点），确保其Y坐标与0号节点相同
                if (node.text === "0") {
                    this.makeSpaceForTrunk(sortedChildren, middleIndex, node.y, unitSpacing, leafYCoords);
                } else {
                    node.y = sortedChildren[middleIndex].y;
                }
            } else {
                // 偶数个子节点：父节点Y坐标等于中间两个子节点Y坐标平均值
                const middleIndex1 = sortedChildren.length / 2 - 1;
                const middleIndex2 = sortedChildren.length / 2;
                
                // 对于0号节点的中间两个子节点，确保它们的Y坐标均值与0号节点相同
                if (node.text === "0") {
                    const targetAvgY = node.y;
                    const targetY1 = targetAvgY - unitSpacing / 2;
                    const targetY2 = targetAvgY + unitSpacing / 2;
                    
                    // 调整中间两个节点的Y坐标
                    sortedChildren[middleIndex1].y = targetY1;
                    sortedChildren[middleIndex2].y = targetY2;
                    this.adjustAllDescendants(sortedChildren[middleIndex1], targetY1, leafYCoords);
                    this.adjustAllDescendants(sortedChildren[middleIndex2], targetY2, leafYCoords);
                    
                    // 调整其他节点
                    for (let i = middleIndex1 - 1; i >= 0; i--) {
                        const child = sortedChildren[i];
                        const nextChild = sortedChildren[i + 1];
                        child.y = nextChild.y - unitSpacing;
                        this.adjustAllDescendants(child, child.y, leafYCoords);
                    }
                    
                    let previousY = targetY2;
                    for (let i = middleIndex2 + 1; i < sortedChildren.length; i++) {
                        const child = sortedChildren[i];
                        child.y = previousY + unitSpacing;
                        previousY = child.y;
                        this.adjustAllDescendants(child, child.y, leafYCoords);
                    }
                } else {
                    node.y = (sortedChildren[middleIndex1].y + sortedChildren[middleIndex2].y) / 2;
                }
            }
        }
        
        leafYCoords.set(node.id, node.y);
    });
}

// 计算每个层级的X坐标
calculateLevelXCoords(levelNodes) {
    const nodeXCoords = new Map();
    const centerX = 200;
    const minHorizontalSpacing = 120;
    
    // 按层级排序
    const sortedLevels = Array.from(levelNodes.keys()).sort((a, b) => a - b);
    
    // 存储每个正向层级的最大结束X坐标
    const levelMaxRightX = new Map();
    // 存储每个反向层级的最小结束X坐标
    const levelMinLeftX = new Map();
    
    // 设置中心节点（深度为0）的X坐标
    if (levelNodes.has(0)) {
        const centerNodes = levelNodes.get(0);
        centerNodes.forEach(node => {
            nodeXCoords.set(node.id, centerX);
        });
    }
    
    // 处理正向思维的节点（深度为正，向右分布）
    const positiveLevels = sortedLevels.filter(level => level > 0);
    positiveLevels.forEach((level) => {
        const nodesInLevel = levelNodes.get(level);
        
        // 初始化当前层级的起始X坐标
        let currentLevelStartX;
        if (level === 1) {
            currentLevelStartX = centerX + minHorizontalSpacing;
        } else {
            const prevLevel = level - 1;
            const prevMaxRightX = levelMaxRightX.get(prevLevel) || centerX;
            currentLevelStartX = prevMaxRightX + minHorizontalSpacing;
        }
        
        // 计算当前层级的最大结束X坐标
        let maxRightX = currentLevelStartX;
        
        // 为当前层级的每个节点分配X坐标
        nodesInLevel.forEach(node => {
            // 计算节点的中心X坐标
            const nodeCenterX = currentLevelStartX + node.width / 2;
            
            // 为所有节点分配相同的X坐标
            nodeXCoords.set(node.id, nodeCenterX);
            
            // 更新当前层级的最大结束X坐标
            const nodeRightX = currentLevelStartX + node.width;
            maxRightX = Math.max(maxRightX, nodeRightX);
        });
        
        // 保存当前正向层级的最大结束X坐标
        levelMaxRightX.set(level, maxRightX);
    });
    
    // 处理反向思维的节点（深度为负，向左分布）
    const negativeLevels = sortedLevels.filter(level => level < 0).sort((a, b) => b - a);
    negativeLevels.forEach((level) => {
        const nodesInLevel = levelNodes.get(level);
        
        // 初始化当前层级的起始X坐标
        let currentLevelEndX;
        if (level === -1) {
            currentLevelEndX = centerX - minHorizontalSpacing;
        } else {
            const prevLevel = level + 1;
            const prevMinLeftX = levelMinLeftX.get(prevLevel) || centerX;
            currentLevelEndX = prevMinLeftX - minHorizontalSpacing;
        }
        
        // 计算当前层级的起始X坐标
        const currentLevelStartX = currentLevelEndX - Math.max(...nodesInLevel.map(node => node.width));
        
        // 计算当前层级的最小结束X坐标
        let minLeftX = currentLevelStartX;
        
        // 为当前层级的每个节点分配X坐标
        nodesInLevel.forEach(node => {
            // 设置节点的中心X坐标
            nodeXCoords.set(node.id, currentLevelStartX + node.width / 2);
            
            // 更新当前层级的最小结束X坐标
            minLeftX = Math.min(minLeftX, currentLevelStartX);
        });
        
        // 保存当前反向层级的最小结束X坐标
        levelMinLeftX.set(level, minLeftX);
    });
    
    return nodeXCoords;
}
```

### 3.3 关键功能实现

1. **节点编号生成**：
   - 创建新节点时自动生成符合规则的编号
   - 支持正向思维（1、21、22）和反向思维（-1、-21、-22）编号
   - 为所有节点生成虚拟子节点编号，确保正确排序

2. **树叶节点布局**：
   - 区分真实叶子节点和虚拟叶子节点
   - 基于虚拟编号进行自然排序
   - 按排序顺序分配Y坐标，保持固定单位间距

   - 虚拟叶子节点与对应的树干节点对齐

3. **树枝节点布局**：
   - 按节点深度从中心向外分布
   - 奇数个子节点时，父节点Y坐标等于中间子节点Y坐标
   - 偶数个子节点时，父节点Y坐标等于中间两个子节点Y坐标平均值
   - 树干节点对齐逻辑适用于所有树枝节点
   - 自动为树干节点空出额外空间，避免被其他分支遮挡

4. **布局稳定性保障**：
   - 先计算树叶节点Y坐标，再计算树枝节点Y坐标，最后计算X坐标
   - 按深度排序处理节点，从最深的节点开始
   - 0号节点固定Y坐标，确保整体布局稳定
   - 自动调整所有后代节点的Y坐标，保持布局一致性
   - 一次迭代即可完成稳定布局

## 4. 实施计划

### 4.1 项目里程碑

| 阶段 | 时间 | 任务 | 交付物 |
|------|------|------|--------|
| 1 | 2026-01-18 | 需求分析与项目策划 | 项目策划文档 |
| 2 | 2026-01-19 | 节点编号模块与树叶节点布局实现 | 编号功能与树叶布局代码 |
| 3 | 2026-01-20 | 树枝节点布局实现 | 树枝布局代码 |
| 4 | 2026-01-21 | 测试与验证 | 测试报告 |
| 5 | 2026-01-22 | 文档与部署 | 最终文档 |

### 4.2 资源需求

- 开发人员：1人
- 测试人员：1人
- 开发环境：HTML5、JavaScript、SVG

## 5. 风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 算法复杂度高 | 性能问题 | 中等 | 优化算法，减少迭代次数 |
| 浏览器兼容性 | 功能受限 | 低 | 测试主流浏览器，添加兼容性处理 |
| 布局稳定性 | 用户体验差 | 高 | 增加多重收敛机制 |

## 6. 验收标准

### 6.1 功能验收

1. **节点编号**：
   - 正向思维节点编号：1、2、3、21、22、23等
   - 反向思维节点编号：-1、-2、-3、-21、-22、-23等

2. **树叶节点布局**：
   - 所有树叶节点按编号逐级扫描排序
   - 按排序顺序从顶部到底部分配Y坐标
   - 每个叶子节点之间保持固定的单位间距
   - 整体分布围绕初始节点（0号）的Y坐标对称

3. **树枝节点布局**：
   - 按节点深度从中心向外分布
   - 奇数个子节点时，父节点Y坐标等于中间子节点Y坐标
   - 偶数个子节点时，父节点Y坐标等于中间两个子节点Y坐标平均值
   - 树干逻辑适用于所有树枝节点
   - 自动为树干节点空出额外空间

4. **布局稳定性**：
   - 一次点击自动布局即可达到稳定状态
   - 0号节点固定Y坐标，确保整体布局稳定
   - 所有叶子节点的Y坐标唯一

5. **树干节点对齐**：
   - 任意树枝节点有奇数个子节点时，父节点Y坐标与中间子节点Y坐标相同
   - 任意树枝节点有偶数个子节点时，父节点Y坐标等于中间两个子节点Y坐标均值
   - 0号节点作为中心，子节点根据规则对齐

6. **水平节点间距**：
   - 正向布局中节点不重叠
   - 相邻节点边的间距为108px
   - 创建新节点时，自动保持108px的水平间距

7. **文本处理**：
   - 文本自动换行，不超出节点框
   - 编辑节点文本时，节点高度根据内容自动调整
   - 文本溢出时，使用CSS clip-path确保文本不超出节点框

8. **端点位置固定**：
   - 编辑节点文本后，节点的左端点位置保持固定
   - 父节点的右端点位置保持固定
   - 根节点的中心位置保持固定

9. **节点对齐**：
   - 所有子节点左端点对齐
   - 所有父节点右端点对齐
   - 使用第一个节点的端点位置作为基准

10. **默认节点宽度**：
    - 所有节点默认宽度为400px
    - 宽度一致性保持良好

### 6.2 性能验收

1. 自动布局计算时间不超过1秒
2. 支持30个以上节点的稳定布局

### 6.3 用户体验验收

1. 界面美观，节点分布均匀
2. 操作简单，一键完成布局

## 7. 后续优化

1. 支持自定义节点间距
2. 实现多种布局样式选择
3. 优化移动端布局效果
4. 支持节点批量操作
5. 进一步优化文本处理逻辑，支持更复杂的文本格式
6. 实现更智能的节点对齐和间距调整算法
7. 优化撤销/重做操作的性能和可靠性
8. 增加更多的节点样式和主题选择

---

策划人：AI助手
日期：2026-01-17