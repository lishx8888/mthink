# 思维导图画布节点编号与自动布局优化项目策划

## 1. 项目背景

思维导图画布的自动布局功能已完成优化，实现了基于节点编号的特定对齐规则，确保一次点击即可达到稳定状态。系统已解决以下问题：
- ✅ 节点编号逻辑不清晰问题，正向和反向思维节点编号已明确分离
- ✅ 布局稳定性不足问题，一次点击即可达到预期效果
- ✅ 对齐规则未完全按用户要求实现问题，已实现所有要求的对齐规则

## 1.1 新增功能

- **节点编号与文字内容分离**：节点编号和文字内容使用独立字段，避免相互干扰
- **自动布局节点编号生成**：为无编号节点自动生成合理的编号
- **坐标系统优化**：将(0,0)点从页面左上角移到页面中央
- **保存与导入优化**：确保节点编号和文字内容在保存和导入过程中不丢失
- **水平节点间距优化**：确保正向布局中节点不重叠，保持相邻节点边的108px间距
- **文本溢出处理**：实现文本自动换行逻辑和CSS clip-path，确保文本不会超出节点框
- **端点位置固定**：编辑节点文本后，节点的端点位置保持固定
- **节点对齐优化**：使用第一个节点的端点位置作为基准，确保所有子节点左端点对齐，所有父节点右端点对齐
- **根节点位置固定**：确保根节点固定在中心(0,0)，包括编辑文本时
- **默认节点宽度**：所有节点默认宽度为400px，保持一致性
- **编辑模式优化**：编辑节点文本时，节点高度根据内容自动调整
- **多选节点样式设置**：选择多个节点时，只修改用户实际调整的样式属性，保持其他属性不变
- **连接线颜色保存**：确保连接线颜色在保存和加载过程中不丢失，保持视觉一致性
- **SVG/PNG导出优化**：确保导出的文件中文本与编辑界面保持一致的左对齐样式，避免文本变成单行显示

## 2. 需求分析

### 2.1 核心功能需求

#### 2.1.1 节点编号规则

**以初始节点为中心节点（编号0），实现以下编号逻辑：**

1. **逆向思维节点（左侧父节点）**：
   - 一级节点：根据节点从上到下的顺序依次为-1、-2、-3...
   - 二级节点：在一级节点编号基础上扩展，如-2号节点的子节点依次为-2.1、-2.2、-2.3...
   - 三级节点：在二级节点编号基础上扩展，如-2.2号节点的子节点依次为-2.2.1、-2.2.2、-2.2.3...
   - 以此类推，层级越深，编号越长
2. **正向思维节点（右侧子节点）**：
   - 一级节点：根据节点从上到下的顺序依次为1、2、3...
   - 二级节点：在一级节点编号基础上扩展，如2号节点的子节点依次为2.1、2.2、2.3...
   - 三级节点：在二级节点编号基础上扩展，如2.2号节点的子节点依次为2.2.1、2.2.2、2.2.3...
   - 以此类推，层级越深，编号越长

#### 2.1.2 自动布局规则

**逆向思维布局规则**：
- 所有没有上级节点的节点（根节点）Y坐标从上往下按编号排序，保持一个单位的竖向间隔
- 上级节点有奇数个时，存在中央节点，其Y坐标等于子节点的Y坐标
- 上级节点有偶数个时，中间节点是两个，这两个节点Y坐标的均值等于子节点的Y坐标
- X坐标为负，与正向思维节点互不干扰

**正向思维布局规则**：
- 所有没有下级节点的节点（叶子节点）Y坐标从上往下按编号排序，保持一个单位的竖向间隔
- 下级节点有奇数个时，存在中央节点，其Y坐标等于父节点的Y坐标
- 下级节点有偶数个时，中间节点是两个，这两个节点Y坐标的均值等于父节点的Y坐标
- X坐标为正，与逆向思维节点互不干扰

### 2.2 非功能需求

- **稳定性**：一次点击自动布局即可达到稳定状态
- **美观性**：布局从中间往两侧排列，节点分布均匀
- **性能**：布局计算时间不超过1秒
- **兼容性**：支持主流浏览器（Chrome、Firefox、Safari、Edge）

## 3. 技术方案

### 3.1 系统架构

保持现有系统架构不变，主要优化以下模块：

1. **节点编号模块**：负责生成和管理节点编号
2. **自动布局模块**：实现基于新规则的布局算法
3. **渲染模块**：确保布局后的节点正确渲染

### 3.2 核心算法设计

#### 3.2.1 节点编号算法

```javascript
// 生成节点编号
generateNodeNumber(parentNode, direction) {
    // direction: 'forward' 或 'reverse'
    const parentNumber = parentNode.nodeNumber;
    const siblings = direction === 'forward' ? parentNode.children : parentNode.parents;
    
    // 对于初始节点（编号为"0"）的特殊处理
    if (parentNumber === "0") {
        // 获取所有兄弟节点的编号
        const siblingNumbers = siblings.map(sibling => {
            return parseInt(sibling.nodeNumber) || 0;
        });
        
        if (direction === 'forward') {
            // 正向思维节点：一级子节点编号1、2、3...
            const maxNumber = siblingNumbers.length > 0 ? Math.max(...siblingNumbers) : 0;
            return `${maxNumber + 1}`;
        } else {
            // 反向思维节点：一级父节点编号-1、-2、-3...
            const minNumber = siblingNumbers.length > 0 ? Math.min(...siblingNumbers) : 0;
            return `${minNumber - 1}`;
        }
    }
    
    // 非初始节点的编号处理
    // 获取所有兄弟节点的编号
    const siblingNumbers = siblings.map(sibling => {
        const siblingText = sibling.nodeNumber;
        // 提取父编号前缀（带分隔符）
        const prefix = parentNumber + ".";
        // 提取兄弟节点编号中父编号后的部分
        const suffix = siblingText.startsWith(prefix) ? siblingText.substring(prefix.length) : siblingText;
        return parseInt(suffix) || 0;
    });
    
    // 计算新编号
    const maxNumber = siblingNumbers.length > 0 ? Math.max(...siblingNumbers) : 0;
    const newNumber = maxNumber + 1;
    
    // 使用点号作为分隔符
    return `${parentNumber}.${newNumber}`;
}
```

#### 3.2.2 自动布局算法

```javascript
// 自动布局主函数
function autoLayout() {
    // 计算节点深度
    const nodeDepths = calculateNodeDepths();
    
    // 按层级分组节点
    const levelNodes = getNodesByLevel(nodeDepths);
    
    // 计算X坐标
    const levelXCoords = calculateLevelXCoords(levelNodes);
    
    // 计算Y坐标
    const leafYCoords = calculateLeafYCoords(levelNodes);
    
    // 应用坐标
    applyNodePositions(levelXCoords, leafYCoords);
    
    // 确保布局稳定
    ensureLayoutStability();
}
```

#### 3.2.3 间距优化算法

##### 3.2.3.1 正向布局间距优化

```javascript
// 优化正向节点间距 - 确保相邻分根节点（包括整个分支）之间保持至少20px的垂直间距
optimizeNodeSpacing() {
    const MIN_VERTICAL_SPACING = 20;
    
    // 1. 只处理正向思维布局的节点（非负编号）
    const forwardNodes = this.nodes.filter(node => !node.nodeNumber.startsWith('-'));
    
    if (forwardNodes.length === 0) {
        return;
    }
    
    // 2. 计算所有正向节点的深度
    const nodeDepths = new Map();
    forwardNodes.forEach(node => {
        const depth = node.nodeNumber.split('.').length;
        nodeDepths.set(node.id, depth);
    });
    
    // 3. 按深度分组节点，从最深的开始处理
    const nodesByDepth = new Map();
    forwardNodes.forEach(node => {
        const depth = nodeDepths.get(node.id);
        if (!nodesByDepth.has(depth)) {
            nodesByDepth.set(depth, []);
        }
        nodesByDepth.get(depth).push(node);
    });
    
    // 4. 按深度从大到小排序（自底而上处理）
    const sortedDepths = Array.from(nodesByDepth.keys()).sort((a, b) => b - a);
    
    // 5. 处理每个深度的节点
    for (const depth of sortedDepths) {
        const nodesAtDepth = nodesByDepth.get(depth);
        
        // 6. 为每个父节点处理其子节点
        const parentNodes = new Set();
        nodesAtDepth.forEach(node => {
            node.parents.forEach(parent => {
                if (forwardNodes.includes(parent)) {
                    parentNodes.add(parent);
                }
            });
        });
        
        // 处理每个正向父节点
        parentNodes.forEach(parent => {
            // 获取父节点的所有正向子节点
            const children = parent.children.filter(child => forwardNodes.includes(child));
            
            if (children.length <= 1) {
                return; // 只有一个子节点，不需要调整
            }
            
            // 7. 计算每个子节点（包括其整个子树）的边界，保持原始顺序
            const childBounds = [];
            children.forEach(child => {
                childBounds.push({
                    node: child,
                    bounds: this.calculateSubtreeBounds(child)
                });
            });
            
            // 8. 从顶部开始，确保每个子节点与其上方的子节点保持至少20px的间距
            for (let i = 1; i < childBounds.length; i++) {
                const prevBounds = childBounds[i - 1].bounds;
                const currentBounds = childBounds[i].bounds;
                
                // 计算当前子节点应该的顶部位置
                const expectedTop = prevBounds.bottom + MIN_VERTICAL_SPACING;
                
                // 如果当前子节点的顶部位置低于预期，需要调整
                if (currentBounds.top < expectedTop) {
                    // 计算需要的偏移量
                    const offset = expectedTop - currentBounds.top;
                    
                    // 调整当前子节点及其所有后代
                    this.adjustNodeAndDescendantsY(childBounds[i].node, offset);
                    
                    // 更新当前子节点的边界
                    childBounds[i].bounds = this.calculateSubtreeBounds(childBounds[i].node);
                    
                    // 更新后续子节点的边界
                    for (let j = i + 1; j < childBounds.length; j++) {
                        childBounds[j].bounds = this.calculateSubtreeBounds(childBounds[j].node);
                    }
                }
            }
        });
    }
    
    // 9. 调整所有正向父节点Y坐标，使其与子节点对齐
    forwardNodes.forEach(node => {
        if (node.children.length > 0) {
            // 获取父节点的所有正向子节点
            const children = node.children.filter(child => forwardNodes.includes(child));
            
            if (children.length > 0) {
                // 按节点编号自然排序子节点
                const sortedChildren = [...children].sort((a, b) => {
                    return a.nodeNumber.localeCompare(b.nodeNumber, undefined, { numeric: true, sensitivity: 'base' });
                });
                
                // 根据子节点数量计算父节点Y坐标
                let parentY;
                if (sortedChildren.length % 2 === 1) {
                    // 奇数个子节点：使用中间子节点的Y坐标
                    const middleIndex = Math.floor(sortedChildren.length / 2);
                    parentY = sortedChildren[middleIndex].y;
                } else {
                    // 偶数个子节点：使用中间两个子节点Y坐标的均值
                    const middleIndex1 = sortedChildren.length / 2 - 1;
                    const middleIndex2 = sortedChildren.length / 2;
                    parentY = (sortedChildren[middleIndex1].y + sortedChildren[middleIndex2].y) / 2;
                }
                
                // 调整父节点Y坐标
                node.y = parentY;
            }
        }
    });
}
```

##### 3.2.3.2 反向布局间距优化

```javascript
// 优化反向节点间距 - 自底而上计算，确保相邻分根节点（包括整个分支）之间保持至少20px的垂直间距
optimizeReverseNodeSpacing() {
    const MIN_VERTICAL_SPACING = 20;
    
    // 1. 只处理反向思维布局的节点（负编号）
    const reverseNodes = this.nodes.filter(node => node.nodeNumber.startsWith('-'));
    
    if (reverseNodes.length === 0) {
        return;
    }
    
    // 2. 计算所有反向节点的深度（深度越大，离0节点越远）
    const nodeDepths = new Map();
    reverseNodes.forEach(node => {
        const nodeNumber = node.nodeNumber.startsWith('-') ? node.nodeNumber.slice(1) : node.nodeNumber;
        const depth = nodeNumber.split('.').length;
        nodeDepths.set(node.id, depth);
    });
    
    // 3. 按深度分组节点，从最深的开始处理（从外到内）
    const nodesByDepth = new Map();
    reverseNodes.forEach(node => {
        const depth = nodeDepths.get(node.id);
        if (!nodesByDepth.has(depth)) {
            nodesByDepth.set(depth, []);
        }
        nodesByDepth.get(depth).push(node);
    });
    
    // 4. 按深度从大到小排序（自底而上处理）
    const sortedDepths = Array.from(nodesByDepth.keys()).sort((a, b) => b - a);
    
    // 5. 处理每个深度的节点
    for (const depth of sortedDepths) {
        const nodesAtDepth = nodesByDepth.get(depth);
        
        // 6. 为每个子节点处理其父节点（分根）
        const childNodes = new Set();
        nodesAtDepth.forEach(node => {
            // 只处理反向布局中的子节点
            node.children.forEach(child => {
                if (reverseNodes.includes(child)) {
                    childNodes.add(child);
                }
            });
        });
        
        // 处理每个反向子节点
        childNodes.forEach(child => {
            // 获取子节点的所有反向父节点（分根）
            const parents = child.parents.filter(parent => reverseNodes.includes(parent));
            
            if (parents.length <= 1) {
                return; // 只有一个父节点，不需要调整
            }
            
            // 7. 计算每个分根的边界（包括其所有父节点）
            const rootBounds = [];
            parents.forEach(parent => {
                rootBounds.push({
                    root: parent,
                    bounds: this.calculateRootBounds(parent)
                });
            });
            
            // 8. 按节点编号自然排序分根，保持原始顺序
            rootBounds.sort((a, b) => {
                return a.root.nodeNumber.localeCompare(b.root.nodeNumber, undefined, { numeric: true, sensitivity: 'base' });
            });
            
            // 9. 从顶部开始，确保每个分根与其上方的分根保持至少20px的间距
            for (let i = 1; i < rootBounds.length; i++) {
                const prevBounds = rootBounds[i - 1].bounds;
                const currentBounds = rootBounds[i].bounds;
                
                // 计算当前分根应该的顶部位置
                const expectedTop = prevBounds.bottom + MIN_VERTICAL_SPACING;
                
                // 如果当前分根的顶部位置低于预期，需要调整
                if (currentBounds.top < expectedTop) {
                    // 计算需要的偏移量
                    const offset = expectedTop - currentBounds.top;
                    
                    // 调整当前分根及其所有父节点
                    this.adjustRootAndAncestorsY(rootBounds[i].root, offset);
                    
                    // 更新当前分根的边界
                    rootBounds[i].bounds = this.calculateRootBounds(rootBounds[i].root);
                    
                    // 更新后续分根的边界
                    for (let j = i + 1; j < rootBounds.length; j++) {
                        rootBounds[j].bounds = this.calculateRootBounds(rootBounds[j].root);
                    }
                }
            }
        });
    }
}

// 优化反向布局中0号节点的父节点（一级节点）之间的间距
optimizeReverseLevel1Spacing() {
    const MIN_VERTICAL_SPACING = 20;
    
    // 1. 找到0号节点
    const node0 = this.nodes.find(node => node.nodeNumber === "0");
    if (!node0) {
        return;
    }
    
    // 2. 获取0号节点的所有反向父节点（一级节点）
    const level1Nodes = node0.parents.filter(parent => parent.nodeNumber.startsWith('-'));
    
    if (level1Nodes.length <= 1) {
        return; // 只有一个或没有父节点，不需要调整
    }
    
    // 3. 按节点编号自然排序，保持原始顺序
    const sortedLevel1Nodes = [...level1Nodes].sort((a, b) => {
        return a.nodeNumber.localeCompare(b.nodeNumber, undefined, { numeric: true, sensitivity: 'base' });
    });
    
    // 4. 计算每个一级节点的边界（包括其整个子树）
    const nodeBounds = [];
    sortedLevel1Nodes.forEach(node => {
        nodeBounds.push({
            node: node,
            bounds: this.calculateRootBounds(node)
        });
    });
    
    // 5. 从顶部开始，确保每个一级节点与其上方的一级节点保持至少20px的间距
    for (let i = 1; i < nodeBounds.length; i++) {
        const prevBounds = nodeBounds[i - 1].bounds;
        const currentBounds = nodeBounds[i].bounds;
        
        // 计算当前一级节点应该的顶部位置
        const expectedTop = prevBounds.bottom + MIN_VERTICAL_SPACING;
        
        // 如果当前一级节点的顶部位置低于预期，需要调整
        if (currentBounds.top < expectedTop) {
            // 计算需要的偏移量
            const offset = expectedTop - currentBounds.top;
            
            // 调整当前一级节点及其所有祖先
            this.adjustRootAndAncestorsY(nodeBounds[i].node, offset);
            
            // 更新当前一级节点的边界
            nodeBounds[i].bounds = this.calculateRootBounds(nodeBounds[i].node);
            
            // 更新后续一级节点的边界
            for (let j = i + 1; j < nodeBounds.length; j++) {
                nodeBounds[j].bounds = this.calculateRootBounds(nodeBounds[j].node);
            }
        }
    }
}

// 计算分根节点及其所有祖先的边界
calculateRootBounds(node) {
    let minX = node.x - node.width / 2;
    let maxX = node.x + node.width / 2;
    let minY = node.y - node.height / 2;
    let maxY = node.y + node.height / 2;
    
    // 递归计算所有父节点的边界
    node.parents.forEach(parent => {
        const parentBounds = this.calculateRootBounds(parent);
        minX = Math.min(minX, parentBounds.left);
        maxX = Math.max(maxX, parentBounds.right);
        minY = Math.min(minY, parentBounds.top);
        maxY = Math.max(maxY, parentBounds.bottom);
    });
    
    return {
        left: minX,
        right: maxX,
        top: minY,
        bottom: maxY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2,
        width: maxX - minX,
        height: maxY - minY
    };
}

// 调整分根节点及其所有祖先的Y坐标
adjustRootAndAncestorsY(node, yOffset) {
    // 调整当前节点
    node.y += yOffset;
    
    // 递归调整所有父节点
    node.parents.forEach(parent => {
        this.adjustRootAndAncestorsY(parent, yOffset);
    });
}
```

#### 3.2.3 节点布局逻辑（树叶与树枝协同）

##### 3.2.3.1 节点类型明确定义

**树叶节点**（Leaf Nodes）：
- 所有没有子节点的外沿节点
- 思维导图的终端节点
- 负责展示思维导图的具体内容细节

**树枝节点**（Branch Nodes）：
- 所有有子节点的内部节点
- 包括树干节点和分叉节点
- 负责连接和组织树叶节点，形成树状结构

##### 3.2.3.2 树叶节点布局逻辑（竖向分布）

树叶节点主要处理竖向的终端节点分布，确保：

1. **编号排序**：
   - 叶子节点定义：没有子节点的节点
   - 排序规则：按叶子节点的编号逐级扫描排序
     - 首先比较首个编号的大小，小的排前面
     - 如果首个编号相同，再比较下一位的编号（如2.1与2.2，首个编号都是2，下一位编号分别是1和2，那么2.1排前面）
     - 依次比较后续位的编号，直到确定大小顺序

2. **Y坐标分配（间距）**：
   - 按排序顺序从顶部到底部分配Y坐标
   - 每个叶子节点之间保持一个固定的单位间距（单位间距 = 节点高度 + 垂直边缘间距）
   - 整体分布围绕初始节点（0号）的Y坐标对称

##### 3.2.3.3 树枝节点布局逻辑（横向与竖向协同）

树枝节点处理横向分布和竖向对齐，确保：

1. **横向分布**：
   - 按节点深度从中心向外分布（深度1、2、3...）
   - 节点之间保持固定的水平间距
   - 正向思维节点向右分布，反向思维节点向左分布

2. **竖向对齐（树干逻辑）**：
   - 树干逻辑适用于所有树枝节点（非叶子节点）
   - **奇数个子节点场景**：
     - 父节点的Y坐标等于中间子节点的Y坐标
     - 示例：节点3有5个子节点（3.1, 3.2, 3.3, 3.4, 3.5），则节点3的Y坐标与3.3的Y坐标相同
     - 中间子节点的虚拟子节点（如3.3.0）必须与父节点Y坐标对齐
   - **偶数个子节点场景**：
     - 父节点的Y坐标等于中间两个子节点的Y坐标均值
     - 示例：节点4有6个子节点（4.1, 4.2, 4.3, 4.4, 4.5, 4.6），则节点4的Y坐标等于4.3和4.4的Y坐标均值
     - 中间两个子节点的虚拟子节点（如4.3.0, 4.4.0）必须与父节点Y坐标对齐

3. **初始节点（0号节点）特殊处理**：
   - 作为整个思维导图的中心，0号节点的Y坐标固定为画布中心位置
   - 当0号节点有奇数个子节点时，中央树干节点的Y坐标与0号节点相同
   - 当0号节点有偶数个子节点时，中间两个分叉树干节点的Y坐标均值与0号节点相同

##### 3.2.3.4 协同工作原理（叶子节点与树干节点的衔接机制）

树叶节点逻辑和树枝节点逻辑相互补充，形成稳定的确定状态，两者的衔接机制如下：

### 1. 节点类型明确定义

**叶子节点**：
- 定义：没有子节点的节点
- 职责：实现竖向的排序以及间距分配
- 特征：树形结构的终端节点，负责展示具体内容细节

**树干节点**：
- 定义：有子节点的节点（包括所有非叶子节点）
- 职责：保证树枝能找准其中央的干节点
- 特征：树形结构的内部节点，负责连接和组织树叶节点

### 2. 衔接机制

#### 2.1 布局计算顺序（先树叶后树干）

1. **树叶节点布局**：
   - 首先计算所有树叶节点的Y坐标
   - 按编号逐级扫描排序叶子节点
   - 按排序顺序分配Y坐标，保持固定单位间距
   - 整体分布围绕初始节点（0号）的Y坐标对称

2. **树干节点布局**：
   - 基于树叶节点的Y坐标计算所有树干节点的Y坐标
   - 按深度从最深的树干节点开始处理（从叶子节点的直接父节点开始）
   - 奇数个子节点时，树干节点Y坐标等于中间子节点Y坐标
   - 偶数个子节点时，树干节点Y坐标等于中间两个子节点Y坐标平均值

3. **X坐标计算**：
   - 最后计算所有节点的X坐标
   - 按节点深度从中心向外分布
   - 正向思维节点向右分布，反向思维节点向左分布

#### 2.2 坐标传递机制

**从叶子节点到树干节点的Y坐标传递**：
- 叶子节点的Y坐标是所有上层树干节点Y坐标的基础
- 每个树干节点的Y坐标直接由其子节点的Y坐标计算得出
- 树干节点通过中间子节点的Y坐标与下层叶子节点建立连接

**树干节点对叶子节点的约束**：
- 树干节点的结构（子节点数量和分布）决定了叶子节点的分布范围
- 树干节点的对齐规则确保叶子节点的分布保持整体平衡
- 树干节点为中心的结构确保整个树形布局的稳定性

### 3. 稳定性保障

1. **单向依赖**：
   - 树干节点的Y坐标完全依赖于其子节点的Y坐标
   - 叶子节点的Y坐标不依赖于树干节点，只受限于排序和间距规则
   - 这种单向依赖关系确保布局计算的稳定收敛

2. **层级处理**：
   - 按深度从下往上处理树干节点，确保子节点坐标先于父节点计算
   - 这种层级处理方式避免了循环依赖，确保布局的确定性

3. **固定约束**：
   - 0号节点Y坐标固定为画布中心，作为整个布局的基准点
   - 叶子节点间距固定，确保布局的一致性
   - 树干节点对齐规则明确，确保布局的稳定性

4. **稳定收敛**：
   - 一次迭代即可完成所有节点的坐标计算
   - 无需多次点击即可达到稳定状态
   - 任意节点的移动都会触发整个布局的重新计算，保持整体稳定性

**实现代码：**

```javascript
// 计算分支中的叶子节点数量
countLeafNodesInBranch(node) {
    if (node.children.length === 0) {
        return 1;
    }
    return node.children.reduce((sum, child) => {
        return sum + this.countLeafNodesInBranch(child);
    }, 0);
}

// 调整所有后代节点的Y坐标
adjustAllDescendants(node, newY, leafYCoords) {
    const originalY = node.y;
    const deltaY = newY - originalY;
    
    // 调整当前节点的Y坐标
    node.y = newY;
    leafYCoords.set(node.id, newY);
    
    // 递归调整所有子节点的Y坐标
    node.children.forEach(child => {
        child.y += deltaY;
        leafYCoords.set(child.id, child.y);
        this.adjustAllDescendants(child, child.y, leafYCoords);
    });
}

// 为树干节点空出额外空间，避免被其他分支遮挡
makeSpaceForTrunk(children, trunkIndex, trunkY, unitSpacing, leafYCoords) {
    // 确保树干节点的Y坐标正确
    children[trunkIndex].y = trunkY;
    this.adjustAllDescendants(children[trunkIndex], trunkY, leafYCoords);
    
    // 调整树干节点上方的节点（向上移动）
    for (let i = trunkIndex - 1; i >= 0; i--) {
        const child = children[i];
        const nextChild = children[i + 1];
        child.y = nextChild.y - unitSpacing;
        this.adjustAllDescendants(child, child.y, leafYCoords);
    }
    
    // 调整树干节点下方的节点（向下移动）
    let previousY = trunkY;
    for (let i = trunkIndex + 1; i < children.length; i++) {
        const child = children[i];
        child.y = previousY + unitSpacing;
        previousY = child.y;
        this.adjustAllDescendants(child, child.y, leafYCoords);
    }
}

// 计算叶子节点的Y坐标（树叶节点布局）
calculateLeafYCoords(leafNodes) {
    const leafYCoords = new Map();
    const baseY = 200;
    const verticalEdgeSpacing = 20;
    const unitSpacing = 49.599999999999994 + verticalEdgeSpacing;
    
    // 找到初始节点（编号为"0"）
    const initialNode = this.nodes.find(node => node.text === "0") || this.nodes[0];
    
    if (initialNode) {
        // 为初始节点设置Y坐标
        initialNode.y = baseY;
        leafYCoords.set(initialNode.id, baseY);
        
        // 计算树的最大级别数
        const maxLevel = this.calculateMaxTreeLevel();
        
        // 按编号逐级扫描排序叶子节点
        const sortedLeafNodes = leafNodes.sort((a, b) => {
            // 按编号逐级扫描排序
            const numA = a.text;
            const numB = b.text;
            
            // 处理负号
            const isANegative = numA.startsWith('-');
            const isBNegative = numB.startsWith('-');
            
            if (isANegative && !isBNegative) {
                return -1;
            } else if (!isANegative && isBNegative) {
                return 1;
            }
            
            // 提取数字部分（去掉负号）
            const numAPart = isANegative ? numA.slice(1) : numA;
            const numBPart = isBNegative ? numB.slice(1) : numB;
            
            // 按字符逐个比较
            for (let i = 0; i < Math.max(numAPart.length, numBPart.length); i++) {
                const digitA = parseInt(numAPart[i] || 0);
                const digitB = parseInt(numBPart[i] || 0);
                
                if (digitA < digitB) {
                    return isANegative ? 1 : -1;
                } else if (digitA > digitB) {
                    return isANegative ? -1 : 1;
                }
            }
            
            // 如果所有数字都相同，则较短的编号排在前面
            if (numAPart.length < numBPart.length) {
                return isANegative ? 1 : -1;
            } else if (numAPart.length > numBPart.length) {
                return isANegative ? -1 : 1;
            }
            
            return 0;
        });
        
        // 为所有叶子节点分配Y坐标
        if (sortedLeafNodes.length > 0) {
            const totalHeight = (sortedLeafNodes.length - 1) * unitSpacing;
            const startY = baseY - totalHeight / 2;
            
            sortedLeafNodes.forEach((leafNode, index) => {
                // 真实叶子节点按顺序分配Y坐标
                const y = startY + index * unitSpacing;
                leafNode.y = y;
                leafYCoords.set(leafNode.id, y);
            });
        }
        
        // 计算非叶子节点的Y坐标
        this.calculateNonLeafYCoords(leafYCoords, unitSpacing);
    }
    
    return leafYCoords;
}

// 计算非叶子节点的Y坐标（树枝节点布局）
calculateNonLeafYCoords(leafYCoords, unitSpacing) {
    // 找出所有非叶子节点
    const nonLeafNodes = this.nodes.filter(node => node.children.length > 0);
    
    // 按深度排序，从最深的节点开始处理
    nonLeafNodes.sort((a, b) => {
        const depthA = this.calculateNodeDepth(a);
        const depthB = this.calculateNodeDepth(b);
        return depthB - depthA;
    });
    
    // 处理所有非叶子节点
    nonLeafNodes.forEach(node => {
        // 按节点编号自然排序子节点
        const sortedChildren = [...node.children].sort((a, b) => {
            return a.text.localeCompare(b.text, undefined, { numeric: true, sensitivity: 'base' });
        });
        
        // 应用树干对齐逻辑
        if (sortedChildren.length > 0) {
            if (sortedChildren.length % 2 === 1) {
                // 奇数个子节点：父节点Y坐标等于中间子节点Y坐标
                const middleIndex = Math.floor(sortedChildren.length / 2);
                
                // 对于0号节点的中间子节点（树干节点），确保其Y坐标与0号节点相同
                if (node.text === "0") {
                    this.makeSpaceForTrunk(sortedChildren, middleIndex, node.y, unitSpacing, leafYCoords);
                } else {
                    node.y = sortedChildren[middleIndex].y;
                }
            } else {
                // 偶数个子节点：父节点Y坐标等于中间两个子节点Y坐标平均值
                const middleIndex1 = sortedChildren.length / 2 - 1;
                const middleIndex2 = sortedChildren.length / 2;
                
                // 对于0号节点的中间两个子节点，确保它们的Y坐标均值与0号节点相同
                if (node.text === "0") {
                    const targetAvgY = node.y;
                    const targetY1 = targetAvgY - unitSpacing / 2;
                    const targetY2 = targetAvgY + unitSpacing / 2;
                    
                    // 调整中间两个节点的Y坐标
                    sortedChildren[middleIndex1].y = targetY1;
                    sortedChildren[middleIndex2].y = targetY2;
                    this.adjustAllDescendants(sortedChildren[middleIndex1], targetY1, leafYCoords);
                    this.adjustAllDescendants(sortedChildren[middleIndex2], targetY2, leafYCoords);
                    
                    // 调整其他节点
                    for (let i = middleIndex1 - 1; i >= 0; i--) {
                        const child = sortedChildren[i];
                        const nextChild = sortedChildren[i + 1];
                        child.y = nextChild.y - unitSpacing;
                        this.adjustAllDescendants(child, child.y, leafYCoords);
                    }
                    
                    let previousY = targetY2;
                    for (let i = middleIndex2 + 1; i < sortedChildren.length; i++) {
                        const child = sortedChildren[i];
                        child.y = previousY + unitSpacing;
                        previousY = child.y;
                        this.adjustAllDescendants(child, child.y, leafYCoords);
                    }
                } else {
                    node.y = (sortedChildren[middleIndex1].y + sortedChildren[middleIndex2].y) / 2;
                }
            }
        }
        
        leafYCoords.set(node.id, node.y);
    });
}

// 计算每个层级的X坐标
calculateLevelXCoords(levelNodes) {
    const nodeXCoords = new Map();
    const centerX = 200;
    const minHorizontalSpacing = 120;
    
    // 按层级排序
    const sortedLevels = Array.from(levelNodes.keys()).sort((a, b) => a - b);
    
    // 存储每个正向层级的最大结束X坐标
    const levelMaxRightX = new Map();
    // 存储每个反向层级的最小结束X坐标
    const levelMinLeftX = new Map();
    
    // 设置中心节点（深度为0）的X坐标
    if (levelNodes.has(0)) {
        const centerNodes = levelNodes.get(0);
        centerNodes.forEach(node => {
            nodeXCoords.set(node.id, centerX);
        });
    }
    
    // 处理正向思维的节点（深度为正，向右分布）
    const positiveLevels = sortedLevels.filter(level => level > 0);
    positiveLevels.forEach((level) => {
        const nodesInLevel = levelNodes.get(level);
        
        // 初始化当前层级的起始X坐标
        let currentLevelStartX;
        if (level === 1) {
            currentLevelStartX = centerX + minHorizontalSpacing;
        } else {
            const prevLevel = level - 1;
            const prevMaxRightX = levelMaxRightX.get(prevLevel) || centerX;
            currentLevelStartX = prevMaxRightX + minHorizontalSpacing;
        }
        
        // 计算当前层级的最大结束X坐标
        let maxRightX = currentLevelStartX;
        
        // 为当前层级的每个节点分配X坐标
        nodesInLevel.forEach(node => {
            // 计算节点的中心X坐标
            const nodeCenterX = currentLevelStartX + node.width / 2;
            
            // 为所有节点分配相同的X坐标
            nodeXCoords.set(node.id, nodeCenterX);
            
            // 更新当前层级的最大结束X坐标
            const nodeRightX = currentLevelStartX + node.width;
            maxRightX = Math.max(maxRightX, nodeRightX);
        });
        
        // 保存当前正向层级的最大结束X坐标
        levelMaxRightX.set(level, maxRightX);
    });
    
    // 处理反向思维的节点（深度为负，向左分布）
    const negativeLevels = sortedLevels.filter(level => level < 0).sort((a, b) => b - a);
    negativeLevels.forEach((level) => {
        const nodesInLevel = levelNodes.get(level);
        
        // 初始化当前层级的起始X坐标
        let currentLevelEndX;
        if (level === -1) {
            currentLevelEndX = centerX - minHorizontalSpacing;
        } else {
            const prevLevel = level + 1;
            const prevMinLeftX = levelMinLeftX.get(prevLevel) || centerX;
            currentLevelEndX = prevMinLeftX - minHorizontalSpacing;
        }
        
        // 计算当前层级的起始X坐标
        const currentLevelStartX = currentLevelEndX - Math.max(...nodesInLevel.map(node => node.width));
        
        // 计算当前层级的最小结束X坐标
        let minLeftX = currentLevelStartX;
        
        // 为当前层级的每个节点分配X坐标
        nodesInLevel.forEach(node => {
            // 设置节点的中心X坐标
            nodeXCoords.set(node.id, currentLevelStartX + node.width / 2);
            
            // 更新当前层级的最小结束X坐标
            minLeftX = Math.min(minLeftX, currentLevelStartX);
        });
        
        // 保存当前反向层级的最小结束X坐标
        levelMinLeftX.set(level, minLeftX);
    });
    
    return nodeXCoords;
}
```

### 3.3 关键功能实现

1. **节点编号生成**：
   - 创建新节点时自动生成符合规则的编号
   - 支持正向思维（1、2、3、2.1、2.2、2.3）和反向思维（-1、-2、-3、-2.1、-2.2、-2.3）编号
   - 使用点号作为层级分隔符，确保编号结构清晰
   - 正向思维节点：一级子节点编号1、2、3...，二级节点在一级节点编号基础上扩展，如2.1、2.2、2.3...
   - 反向思维节点：一级父节点编号-1、-2、-3...，二级节点在一级节点编号基础上扩展，如-2.1、-2.2、-2.3...

2. **树叶节点布局**：
   - 区分真实叶子节点和虚拟叶子节点
   - 基于虚拟编号进行自然排序
   - 按排序顺序分配Y坐标，保持固定单位间距

   - 虚拟叶子节点与对应的树干节点对齐

3. **树枝节点布局**：
   - 按节点深度从中心向外分布
   - 奇数个子节点时，父节点Y坐标等于中间子节点Y坐标
   - 偶数个子节点时，父节点Y坐标等于中间两个子节点Y坐标平均值
   - 树干节点对齐逻辑适用于所有树枝节点
   - 自动为树干节点空出额外空间，避免被其他分支遮挡

4. **布局稳定性保障**：
   - 先计算树叶节点Y坐标，再计算树枝节点Y坐标，最后计算X坐标
   - 按深度排序处理节点，从最深的节点开始
   - 0号节点固定Y坐标，确保整体布局稳定
   - 自动调整所有后代节点的Y坐标，保持布局一致性
   - 一次迭代即可完成稳定布局

## 4. 实施计划

### 4.1 项目里程碑

| 阶段 | 时间 | 任务 | 交付物 |
|------|------|------|--------|
| 1 | 2026-01-18 | 需求分析与项目策划 | 项目策划文档 |
| 2 | 2026-01-19 | 节点编号模块与树叶节点布局实现 | 编号功能与树叶布局代码 |
| 3 | 2026-01-20 | 树枝节点布局实现 | 树枝布局代码 |
| 4 | 2026-01-21 | 测试与验证 | 测试报告 |
| 5 | 2026-01-22 | 文档与部署 | 最终文档 |

### 4.2 资源需求

- 开发人员：1人
- 测试人员：1人
- 开发环境：HTML5、JavaScript、SVG

## 5. 风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 算法复杂度高 | 性能问题 | 中等 | 优化算法，减少迭代次数 |
| 浏览器兼容性 | 功能受限 | 低 | 测试主流浏览器，添加兼容性处理 |
| 布局稳定性 | 用户体验差 | 高 | 增加多重收敛机制 |

## 6. 验收标准

### 6.1 功能验收

1. **节点编号**：
   - 正向思维节点编号：1、2、3、2.1、2.2、2.3等
   - 反向思维节点编号：-1、-2、-3、-2.1、-2.2、-2.3等

2. **树叶节点布局**：
   - 所有树叶节点按编号逐级扫描排序
   - 按排序顺序从顶部到底部分配Y坐标
   - 每个叶子节点之间保持固定的单位间距
   - 整体分布围绕初始节点（0号）的Y坐标对称

3. **树枝节点布局**：
   - 按节点深度从中心向外分布
   - 奇数个子节点时，父节点Y坐标等于中间子节点Y坐标
   - 偶数个子节点时，父节点Y坐标等于中间两个子节点Y坐标平均值
   - 树干逻辑适用于所有树枝节点
   - 自动为树干节点空出额外空间

4. **布局稳定性**：
   - 一次点击自动布局即可达到稳定状态
   - 0号节点固定Y坐标，确保整体布局稳定
   - 所有叶子节点的Y坐标唯一

5. **树干节点对齐**：
   - 任意树枝节点有奇数个子节点时，父节点Y坐标与中间子节点Y坐标相同
   - 任意树枝节点有偶数个子节点时，父节点Y坐标等于中间两个子节点Y坐标均值
   - 0号节点作为中心，子节点根据规则对齐

6. **水平节点间距**：
   - 正向布局中节点不重叠
   - 相邻节点边的间距为108px
   - 创建新节点时，自动保持108px的水平间距

7. **文本处理**：
   - 文本自动换行，不超出节点框
   - 编辑节点文本时，节点高度根据内容自动调整
   - 文本溢出时，使用CSS clip-path确保文本不超出节点框

8. **端点位置固定**：
   - 编辑节点文本后，节点的左端点位置保持固定
   - 父节点的右端点位置保持固定
   - 根节点的中心位置保持固定

9. **节点对齐**：
   - 所有子节点左端点对齐
   - 所有父节点右端点对齐
   - 使用第一个节点的端点位置作为基准

10. **默认节点宽度**：
    - 所有节点默认宽度为400px
    - 宽度一致性保持良好

### 6.2 性能验收

1. 自动布局计算时间不超过1秒
2. 支持30个以上节点的稳定布局

### 6.3 用户体验验收

1. 界面美观，节点分布均匀
2. 操作简单，一键完成布局

## 7. 后续优化

1. 支持自定义节点间距
2. 实现多种布局样式选择
3. 优化移动端布局效果
4. 支持节点批量操作
5. 进一步优化文本处理逻辑，支持更复杂的文本格式
6. 实现更智能的节点对齐和间距调整算法
7. 优化撤销/重做操作的性能和可靠性
8. 增加更多的节点样式和主题选择

---

策划人：AI助手
日期：2026-01-17
## 8. ����Ż��㷨

### 8.1 ���򲼾ּ���Ż�

���򲼾ּ���Ż��㷨ȷ�����ڷָ��ڵ㣨����������֧��֮�䱣������20px�Ĵ�ֱ��ࡣ�㷨������Ľڵ㿪ʼ�������Ե׶��ϼ���ÿ���ָ��ڵ�ı߽磬��ȷ������֮�䱣���ʵ��ļ�ࡣ

### 8.2 ���򲼾ּ���Ż�

���򲼾ּ���Ż��㷨���������򲼾����Ƶ�ԭ����������˳���෴�����⵽�ڴ����ڵ㡣�ر���Ҫע����ǣ����򲼾�����Ҫ�����ڵ����������������Ϊһ�����壨�ָ����������ࡣ

### 8.3 ���ĺ���

- optimizeNodeSpacing(): �Ż�����ڵ���
- optimizeReverseNodeSpacing(): �Ż�����ڵ���
- optimizeReverseLevel1Spacing(): ר���Ż�0�Žڵ�ĸ��ڵ�֮��ļ��
- calculateRootBounds(node): ����ָ��ڵ㼰���������ȵı߽�
- djustRootAndAncestorsY(node, yOffset): �����ָ��ڵ㼰���������ȵ�Y����

