# 多思维图并存功能分析报告与项目策划

## 1. 当前代码结构分析

### 1.1 节点编号机制

当前系统使用以下节点编号机制：

- 中心节点（初始节点）编号为 "0"
- 正向思维节点（右侧）使用正整数编号（1, 2, 3...）
- 反向思维节点（左侧）使用负整数编号（-1, -2, -3...）
- 层级结构通过点号分隔（如 1.1, 1.2, -1.1, -1.2）

### 1.2 布局计算

布局计算基于以下原则：

1. 所有节点的布局都以编号为 "0" 的中心节点为基准
2. 正向思维节点（右侧）按深度和编号排序计算位置
3. 反向思维节点（左侧）同样按深度和编号排序计算位置
4. 布局完成后，整个思维图会被平移，使中心节点回到原点 (0, 0)

### 1.3 核心代码流程

- `generateNodeNumbersForAutoLayout()`: 为所有没有编号的节点生成编号
- `calculateRightNodePositions()`: 计算右侧节点位置
- `calculateLeftNodePositions()`: 计算左侧节点位置
- `optimizeNodeSpacing()`: 优化节点间距
- 最后将整个思维图平移，使中心节点回到原点

## 2. 多思维图并存的需求和挑战

### 2.1 核心需求

1. **多思维图并存**：在同一画布上同时显示多个独立的思维图
2. **独立布局**：每个思维图有自己的布局，不受其他思维图影响
3. **无冲突导入**：导入其他思维图时不会与现有思维图产生冲突
4. **思维图管理**：能够对思维图进行选择、移动、缩放等操作
5. **思维图合并**：能够将多个思维图合并为一个新的思维图
6. **思维图拆分**：能够将一个思维图拆分为多个独立的思维图
7. **智能冲突解决**：合并时自动解决节点编号和位置冲突

### 2.2 主要挑战

1. **节点编号冲突**：多个思维图的初始节点都使用 "0" 编号
2. **坐标冲突**：多个思维图的中心节点都试图占据 (0, 0) 位置
3. **布局计算**：当前布局算法假设只有一个中心节点
4. **节点关系**：不同思维图的节点之间可能产生错误的父子关系
5. **用户交互**：需要区分用户操作针对的是哪个思维图
6. **思维图合并**：合并时需要解决节点编号、位置、样式等冲突
7. **合并后布局**：合并后的思维图需要合理布局，避免节点重叠
8. **用户意图识别**：需要理解用户希望如何合并思维图（如以哪个为中心，如何组织层级）
9. **思维图拆分**：拆分时需要确定拆分点和新思维图的中心节点
10. **拆分后关系**：拆分后需要处理原思维图中节点之间的关系
11. **拆分后布局**：拆分后的新思维图需要独立的合理布局

## 3. 节点属性优化方案

### 3.1 新增节点属性

| 属性名 | 类型 | 描述 | 默认值 |
|-------|------|------|-------|
| `mindMapId` | String | 思维图唯一标识符 | 自动生成 |
| `localNodeNumber` | String | 思维图内的节点编号 | 保持现有编号 |
| `isCenterNode` | Boolean | 是否为思维图的中心节点 | false |

### 3.2 节点编号机制优化

- 每个思维图有自己独立的编号体系
- 思维图内仍使用现有的编号规则（0, 1, 2, -1, -2 等）
- 通过 `mindMapId` 区分不同思维图的节点

### 3.3 坐标系统优化

- 每个思维图有自己的局部坐标系统
- 思维图的中心节点在局部坐标中为 (0, 0)
- 渲染时将局部坐标转换为全局坐标

## 4. 多思维图管理方案

### 4.1 思维图数据结构

```javascript
class MindMap {
  constructor(id, name) {
    this.id = id;              // 思维图唯一标识符
    this.name = name;          // 思维图名称
    this.nodes = [];           // 思维图包含的节点
    this.position = { x: 0, y: 0 };  // 思维图在画布上的位置
    this.scale = 1;            // 思维图的缩放比例
    this.connectionColor = '#000000'; // 连接线颜色
  }
}
```

### 4.2 布局计算优化

1. **局部布局计算**：
   - 对每个思维图单独计算布局
   - 布局计算时使用思维图的局部坐标系统

2. **全局坐标转换**：
   - 渲染时将每个思维图的局部坐标转换为全局坐标
   - 考虑思维图的位置和缩放比例

### 4.3 导入/导出机制

1. **导出**：
   - 可以导出单个思维图
   - 可以导出所有思维图

2. **导入**：
   - 导入思维图时自动生成新的 `mindMapId`
   - 导入的思维图默认放置在画布的空白区域

### 4.4 用户交互

1. **思维图选择**：
   - 点击思维图的任意节点选择整个思维图
   - 显示思维图边界框和控制点

2. **思维图操作**：
   - 移动：拖动思维图边界框
   - 缩放：使用边界框的缩放控制点
   - 重命名：双击思维图名称
   - 删除：选择思维图后按 Delete 键

3. **节点操作**：
   - 保持现有的节点操作逻辑
   - 确保操作只影响当前选中思维图的节点

## 5. 实现计划

### 5.1 阶段一：核心数据结构优化

1. **修改 Node 类**：
   - 添加 `mindMapId`、`localNodeNumber`、`isCenterNode` 属性
   - 修改构造函数和相关方法

2. **创建 MindMap 类**：
   - 实现思维图的基本属性和方法
   - 管理思维图的节点集合

3. **修改现有方法**：
   - 更新 `loadState`、`saveState` 方法以支持多思维图
   - 更新 `importFromJson` 方法以支持导入新思维图

### 5.2 阶段二：布局计算优化

1. **修改布局算法**：
   - 为每个思维图单独计算布局
   - 使用思维图的局部坐标系统

2. **实现坐标转换**：
   - 渲染时将局部坐标转换为全局坐标
   - 考虑思维图的位置和缩放

3. **优化节点间距**：
   - 确保不同思维图之间有适当的间距
   - 避免思维图之间的节点重叠

### 5.3 阶段三：用户交互实现

1. **思维图选择**：
   - 实现思维图选择功能
   - 显示思维图边界框和控制点

2. **思维图操作**：
   - 实现思维图的移动、缩放、重命名、删除操作

3. **节点操作优化**：
   - 确保节点操作只影响当前思维图
   - 优化选择逻辑，区分节点选择和思维图选择

### 5.4 阶段四：导入/导出功能

1. **修改导出功能**：
   - 支持导出单个思维图
   - 支持导出所有思维图

2. **修改导入功能**：
   - 支持导入新思维图
   - 自动处理思维图冲突

3. **测试和优化**：
   - 测试导入/导出功能
   - 优化性能和用户体验

### 5.5 阶段五：思维图合并功能

1. **实现思维图选择**：
   - 支持选择多个思维图进行合并
   - 提供合并选项界面
   - 支持选择特定节点进行关联

2. **实现合并模式**：
   - **完全合并模式**：将多个思维图合并成一个新的思维图
     - 选择一个思维图作为主思维图或创建新的中心节点
     - 解决节点编号冲突
     - 处理节点位置冲突
     - 保持节点的层级关系
   - **节点关联模式**：保留两个思维图独立，仅关联特定节点
     - 选择两个思维图中的节点建立关联关系
     - 绘制关联连接线
     - 保持思维图的独立性

3. **合并后布局**：
   - **完全合并模式**：为合并后的思维图计算合理布局
   - **节点关联模式**：调整思维图位置，确保关联连接线清晰可见
   - 确保节点间距适当，避免重叠

4. **用户交互优化**：
   - 提供合并预览
   - 允许用户调整合并参数
   - 支持撤销合并操作
   - 提供合并模式选择界面

5. **测试和优化**：
   - 测试各种合并场景
   - 优化合并性能和用户体验

### 5.6 阶段六：思维图拆分功能

1. **实现拆分点选择**：
   - 支持选择思维图中的节点作为拆分点
   - 提供拆分选项界面

2. **实现拆分模式**：
   - **节点分支拆分**：将选定节点及其所有子节点拆分为新思维图
   - **层级拆分**：按层级将思维图拆分为多个独立思维图

3. **拆分后处理**：
   - 为新思维图生成独立的节点编号
   - 计算新思维图的布局
   - 调整原思维图和新思维图的位置

4. **用户交互优化**：
   - 提供拆分预览
   - 允许用户调整拆分参数
   - 支持撤销拆分操作

5. **测试和优化**：
   - 测试各种拆分场景
   - 优化拆分性能和用户体验

## 6. 技术实现要点

### 6.1 节点标识

- 使用 `mindMapId` + `localNodeNumber` 作为节点的唯一标识
- 确保在整个系统中节点标识的唯一性

### 6.2 布局计算

- 每个思维图的布局计算独立进行
- 布局计算完成后，再考虑思维图的全局位置

### 6.3 渲染优化

- 批量渲染同一思维图的节点
- 使用适当的缓存策略提高渲染性能

### 6.4 事件处理

- 事件处理时需要确定事件目标所属的思维图
- 实现事件委托，提高事件处理效率

### 6.5 思维图合并实现

#### 6.5.1 完全合并模式

- **合并策略**：
  - 选择一个思维图作为主思维图，其他作为从属思维图
  - 或创建新的中心节点作为合并后的中心
  - 从属思维图的节点将被添加到主思维图中
  - 为从属思维图的节点生成新的唯一编号

- **编号冲突解决**：
  - 分析主思维图的编号空间
  - 为从属思维图的节点分配不冲突的编号
  - 保持从属思维图内部的层级关系

- **位置冲突解决**：
  - 计算合并后节点的最佳位置
  - 避免节点重叠
  - 保持思维图的整体布局平衡

#### 6.5.2 节点关联模式

- **关联策略**：
  - 选择两个思维图中的特定节点建立关联
  - 保持两个思维图的独立性
  - 创建关联连接线表示节点间的关系

- **关联连接线实现**：
  - 使用特殊样式的连接线表示关联关系
  - 连接线应清晰可见，不与思维图内部连接线混淆
  - 支持调整连接线样式和颜色

- **思维图位置调整**：
  - 自动调整思维图位置，确保关联连接线清晰
  - 保持思维图内部布局不变

#### 6.5.3 合并预览

- 在合并前生成预览效果
- 允许用户调整合并参数
- 显示合并后的预期布局
- 为两种合并模式提供不同的预览效果

### 6.6 思维图拆分实现

#### 6.6.1 节点分支拆分

- **拆分策略**：
  - 选择一个节点作为拆分点
  - 将该节点及其所有子节点从原思维图中分离
  - 创建新思维图，以该节点作为中心节点

- **节点关系处理**：
  - 断开原思维图与拆分节点的连接
  - 在新思维图中重新建立节点间的层级关系

- **编号处理**：
  - **新思维图编号**：为新思维图生成独立的节点编号体系
    - 中心节点编号重置为"0"
    - 子节点编号重新计算，从1开始递增
    - 保持层级关系的编号结构（如1.1, 1.2等）
  - **原思维图编号**：重新整理原思维图的节点编号
    - 保持中心节点编号为"0"
    - 重新计算剩余节点的编号，确保连续性
    - 保持层级关系的编号结构
    - 处理可能的编号间隙，重新分配连续编号
  - **编号冲突检测**：确保新生成的编号与原思维图不冲突

- **中心节点标识**：
  - 为新思维图的中心节点添加独立的`isCenterNode`标识
  - 确保新思维图的中心节点编号为"0"
  - 原思维图的中心节点标识保持不变

- **布局对齐处理**：
  - **原思维图**：重新计算布局，保持剩余节点的对齐
  - **新思维图**：以拆分点为中心重新计算布局，确保节点对齐
  - 使用与原思维图相同的布局算法，确保视觉一致性

- **位置调整**：
  - 自动调整原思维图和新思维图的位置，避免重叠
  - 保持合理的间距，确保布局清晰

#### 6.6.2 层级拆分

- **拆分策略**：
  - 选择拆分的层级深度
  - 按层级将思维图拆分为多个独立思维图

- **层级关系处理**：
  - 确保每个拆分后的思维图都有完整的层级结构
  - 保持思维图间的逻辑关系

- **中心节点标识**：
  - 为每个拆分后的思维图指定中心节点
  - 为中心节点添加`isCenterNode`标识
  - 确保每个新思维图的中心节点编号为"0"

- **编号重新整理**：
  - **层级拆分编号**：为每个拆分后的思维图重新整理编号
    - 中心节点编号重置为"0"
    - 各层级节点编号重新计算，保持层级结构
    - 确保不同思维图间的编号不冲突
  - **原思维图编号**：如果原思维图仍然存在（部分层级被拆分），重新整理其编号
    - 保持中心节点编号为"0"
    - 重新计算剩余节点的编号，确保连续性
    - 处理可能的编号间隙，重新分配连续编号
  - **编号连续性**：确保每个思维图内部的编号连续，无间隔
  - **层级关系保持**：保持原思维图中的层级关系，反映在编号结构中

- **布局对齐处理**：
  - **各层级思维图**：为每个拆分后的思维图单独计算布局，确保内部节点对齐
  - **整体布局**：调整多个拆分后思维图的相对位置，保持整体视觉对齐
  - 使用统一的布局算法，确保所有思维图的视觉一致性

- **位置协调**：
  - 按原思维图的层级顺序排列拆分后的思维图
  - 保持适当的间距，确保思维图间的关系清晰可见

#### 6.6.3 拆分预览

- 在拆分前生成预览效果
- 允许用户调整拆分参数
- 显示拆分后的预期布局
- **布局对齐预览**：在预览中显示拆分后的节点对齐情况
- 为两种拆分模式提供不同的预览效果
- 允许用户在预览中调整思维图位置，优化布局对齐

## 7. 预期效果

### 7.1 功能效果

1. **多思维图并存**：在同一画布上同时显示多个独立的思维图
2. **独立布局**：每个思维图有自己的布局，不受其他思维图影响
3. **无冲突导入**：导入其他思维图时不会与现有思维图产生冲突
4. **思维图管理**：能够对思维图进行选择、移动、缩放等操作
5. **完全合并模式**：能够将多个思维图合并为一个新的思维图
6. **节点关联模式**：保留两个思维图独立，仅关联特定节点
7. **思维图拆分**：能够将一个思维图拆分为多个独立的思维图
8. **智能冲突解决**：合并时自动解决节点编号和位置冲突
9. **合并预览**：在合并前可以预览合并效果，调整合并参数
10. **拆分预览**：在拆分前可以预览拆分效果，调整拆分参数
11. **关联连接线**：在节点关联模式下显示思维图之间的关联关系

### 7.2 用户体验

1. **直观操作**：用户可以通过熟悉的方式操作思维图
2. **清晰反馈**：操作时有明确的视觉反馈
3. **流畅性能**：即使多个思维图并存，系统仍然保持流畅
4. **易于理解**：思维图之间的关系和操作逻辑清晰易懂
5. **合并模式选择**：用户可以根据需要选择适合的合并模式
6. **完全合并体验**：用户可以轻松将多个思维图合并为一个
7. **节点关联体验**：用户可以灵活关联不同思维图的节点
8. **思维图拆分体验**：用户可以轻松将一个思维图拆分为多个
9. **合并预览直观**：合并前可以清楚地看到合并效果
10. **拆分预览直观**：拆分前可以清楚地看到拆分效果
11. **合并结果可控**：用户可以调整合并参数，控制合并结果
12. **拆分结果可控**：用户可以调整拆分参数，控制拆分结果
13. **关联关系清晰**：节点关联模式下，思维图之间的关系清晰可见

## 8. 风险评估

### 8.1 技术风险

1. **布局计算复杂度**：多思维图布局计算可能会增加系统复杂度和计算量
2. **坐标转换错误**：局部坐标和全局坐标之间的转换可能会出现错误
3. **性能问题**：多个思维图并存可能会导致性能下降
4. **完全合并算法复杂度**：完全合并模式的算法可能会非常复杂，特别是处理复杂的层级关系
5. **合并后布局质量**：合并后的思维图可能会出现布局不合理的情况
6. **用户操作错误**：用户可能会误操作导致思维图合并结果不符合预期
7. **节点关联复杂度**：节点关联模式需要处理思维图之间的复杂关系
8. **关联连接线管理**：多个关联连接线可能会导致视觉混乱
9. **合并模式选择困惑**：用户可能会对两种合并模式的选择感到困惑
10. **思维图拆分复杂度**：拆分算法可能会非常复杂，特别是处理复杂的层级关系
11. **拆分后布局质量**：拆分后的思维图可能会出现布局不合理的情况
12. **拆分点选择错误**：用户可能会选择错误的拆分点，导致拆分结果不符合预期
13. **拆分模式选择困惑**：用户可能会对两种拆分模式的选择感到困惑

### 8.2 解决方案

1. **优化布局算法**：使用更高效的布局算法，减少计算量
2. **详细测试**：对坐标转换进行详细测试，确保正确性
3. **性能优化**：使用缓存、批量渲染等技术优化性能
4. **渐进式实现**：分阶段实现，确保每个阶段都能正常工作
5. **简化完全合并算法**：设计简洁而有效的完全合并算法，优先处理常见场景
6. **合并预览**：提供合并预览功能，让用户在合并前了解结果
7. **撤销功能**：支持撤销合并操作，减少用户误操作的影响
8. **合并向导**：提供合并向导，引导用户完成合并操作，减少错误
9. **节点关联管理**：提供关联连接线的管理工具，避免视觉混乱
10. **模式选择指南**：提供合并模式选择的详细说明和示例，帮助用户做出正确选择
11. **关联关系可视化**：使用不同样式和颜色的连接线，清晰表示不同类型的关联关系
12. **简化拆分算法**：设计简洁而有效的拆分算法，优先处理常见场景
13. **拆分预览**：提供拆分预览功能，让用户在拆分前了解结果
14. **拆分向导**：提供拆分向导，引导用户完成拆分操作，减少错误
15. **拆分模式选择指南**：提供拆分模式选择的详细说明和示例，帮助用户做出正确选择

## 9. 结论

通过优化节点属性和实现多思维图管理机制，可以实现多思维图并存的功能，满足用户在同一画布上管理多个独立思维图的需求，并为思维图的合并和拆分操作提供基础。这将大大提高系统的灵活性和实用性，使用户能够更有效地组织、管理、整合和重构复杂的思维内容。

### 合并功能
完全合并模式允许用户将多个思维图合并为一个新的思维图，适合需要整合不同思维内容的场景。节点关联模式则保留思维图的独立性，仅通过关联连接线表示节点间的关系，适合需要保持思维图独立性同时展示它们之间联系的场景。

### 拆分功能
节点分支拆分模式允许用户将选定节点及其子节点拆分为新思维图，适合需要将特定主题分离出来单独处理的场景。层级拆分模式则按层级将思维图拆分为多个独立思维图，适合需要按层次结构重组思维内容的场景。

实现这些功能需要对现有代码进行较大的修改，但通过合理的规划和分阶段实现，可以确保系统的稳定性和性能。合并和拆分功能的实现将成为系统的重要亮点，使用户能够根据具体需求选择合适的操作方式，促进知识的融合、创新和重构。

同时，这一功能的实现也将为系统的未来扩展奠定基础，如思维图之间的对比分析、知识图谱构建等高级功能，进一步提升系统的价值和用户体验。